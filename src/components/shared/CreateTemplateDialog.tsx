
import React, { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from '@/components/ui/dialog';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { Plus, FileCode, Sparkles } from 'lucide-react';
import { useProjectFiles } from '@/contexts/ProjectFilesContext';

interface CreateTemplateDialogProps {
  trigger?: React.ReactNode;
  onTemplateCreated?: (templateId: string) => void;
}

const templateTypes = [
  { value: 'linker', label: 'Linker Script', description: 'Memory layout and section definitions' },
  { value: 'rcc', label: 'RCC Configuration', description: 'Clock configuration and PLL settings' },
  { value: 'gpio', label: 'GPIO Configuration', description: 'Pin assignments and GPIO setup' },
  { value: 'middleware', label: 'Middleware Config', description: 'RTOS and middleware configuration' },
  { value: 'main', label: 'Main Application', description: 'Main application entry point' },
  { value: 'makefile', label: 'Makefile', description: 'Build system configuration' },
  { value: 'custom', label: 'Custom Template', description: 'Blank template for custom use' }
];

export const CreateTemplateDialog: React.FC<CreateTemplateDialogProps> = ({
  trigger,
  onTemplateCreated
}) => {
  const { createNewTemplate } = useProjectFiles();
  const [open, setOpen] = useState(false);
  const [templateName, setTemplateName] = useState('');
  const [templateType, setTemplateType] = useState('');
  const [description, setDescription] = useState('');
  const [isCreating, setIsCreating] = useState(false);

  const getTemplateContent = (type: string, name: string): string => {
    const templates = {
      linker: `/* ${name} - STM32 Linker Script Template */
/* Generated by STM32Cube Builder */

MEMORY
{
  FLASH (rx)      : ORIGIN = 0x08000000, LENGTH = {{ flash_size }}K
  RAM (xrw)       : ORIGIN = 0x20000000, LENGTH = {{ ram_size }}K
}

ENTRY(Reset_Handler)

SECTIONS
{
  .isr_vector :
  {
    . = ALIGN(4);
    KEEP(*(.isr_vector))
    . = ALIGN(4);
  } >FLASH

  .text :
  {
    . = ALIGN(4);
    *(.text)
    *(.text*)
    {% for middleware in config.middleware %}
    *(.{{ middleware }}_text)
    {% endfor %}
    . = ALIGN(4);
  } >FLASH
}`,
      rcc: `/* ${name} - RCC Configuration Template */
/* Generated by STM32Cube Builder */

void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /* Configure the main internal regulator output voltage */
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  /* Initializes the RCC Oscillators */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = {{ pll_m | default(8) }};
  RCC_OscInitStruct.PLL.PLLN = {{ pll_n | default(336) }};
  RCC_OscInitStruct.PLL.PLLP = {{ pll_p | default(2) }};
  RCC_OscInitStruct.PLL.PLLQ = {{ pll_q | default(7) }};
  
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }
}`,
      gpio: `/* ${name} - GPIO Configuration Template */
/* Generated by STM32Cube Builder */

static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* GPIO Ports Clock Enable */
  {% for port in config.gpio_ports %}
  __HAL_RCC_GPIO{{ port }}_CLK_ENABLE();
  {% endfor %}

  {% for pin in config.gpio_pins %}
  /* Configure {{ pin.name }} */
  GPIO_InitStruct.Pin = {{ pin.pin }};
  GPIO_InitStruct.Mode = {{ pin.mode }};
  GPIO_InitStruct.Pull = {{ pin.pull }};
  GPIO_InitStruct.Speed = {{ pin.speed }};
  HAL_GPIO_Init(GPIO{{ pin.port }}, &GPIO_InitStruct);
  {% endfor %}
}`,
      middleware: `/* ${name} - Middleware Configuration Template */
/* Generated by STM32Cube Builder */

#ifndef {{ name.upper().replace('-', '_') }}_H
#define {{ name.upper().replace('-', '_') }}_H

{% if config.threadx %}
/* ThreadX Configuration */
#define TX_MAX_PRIORITIES                   {{ tx_max_priorities | default(32) }}
#define TX_MINIMUM_STACK                    {{ tx_minimum_stack | default(200) }}
#define TX_TIMER_TICKS_PER_SECOND           {{ tx_timer_ticks | default(1000) }}
{% endif %}

{% if config.filex %}
/* FileX Configuration */
#define FX_MAX_FILES                        {{ fx_max_files | default(32) }}
#define FX_SECTOR_SIZE                      {{ fx_sector_size | default(512) }}
{% endif %}

{% if config.netxduo %}
/* NetXDuo Configuration */
#define NX_IP_PERIODIC_RATE                 {{ nx_ip_rate | default(100) }}
#define NX_TCP_SOCKET_CONNECTION_TIMEOUT    {{ nx_tcp_timeout | default(10) }}
{% endif %}

#endif /* {{ name.upper().replace('-', '_') }}_H */`,
      main: `/* ${name} - Main Application Template */
/* Generated by STM32Cube Builder */

#include "main.h"
{% for include in config.includes %}
#include "{{ include }}"
{% endfor %}

/* Private variables */
{% for variable in config.variables %}
{{ variable.type }} {{ variable.name }}{% if variable.value %} = {{ variable.value }}{% endif %};
{% endfor %}

int main(void)
{
  /* MCU Configuration */
  HAL_Init();
  SystemClock_Config();
  
  /* Initialize peripherals */
  {% for peripheral in config.peripherals %}
  MX_{{ peripheral }}_Init();
  {% endfor %}

  {% if config.rtos %}
  /* Start scheduler */
  osKernelStart();
  {% else %}
  /* Infinite loop */
  while (1)
  {
    /* User code here */
    {% for task in config.main_loop_tasks %}
    {{ task }}();
    {% endfor %}
  }
  {% endif %}
}`,
      makefile: `# ${name} - Makefile Template
# Generated by STM32Cube Builder

TARGET = {{ project_name }}
BUILD_DIR = build

# C sources
C_SOURCES = \\
{% for source in config.c_sources %}
{{ source }} \\
{% endfor %}

# ASM sources
ASM_SOURCES = \\
{% for source in config.asm_sources %}
{{ source }} \\
{% endfor %}

# C defines
C_DEFS = \\
{% for define in config.defines %}
-D{{ define }} \\
{% endfor %}

# C includes
C_INCLUDES = \\
{% for include in config.includes %}
-I{{ include }} \\
{% endfor %}

# compile gcc flags
CFLAGS = $(C_DEFS) $(C_INCLUDES) $(OPT) -Wall -fdata-sections -ffunction-sections

ifeq ($(DEBUG), 1)
CFLAGS += -g -gdwarf-2
endif

# Generate dependency information
CFLAGS += -MMD -MP -MF"$(@:%.o=%.d)"`,
      custom: `/* ${name} - Custom Template */
/* Generated by STM32Cube Builder */
/* Description: ${description || 'Custom template for specific use case'} */

{% if config.header_comment %}
/*
 * {{ config.header_comment }}
 */
{% endif %}

/* Add your custom template content here */`
    };

    return templates[type] || templates.custom;
  };

  const handleCreate = async () => {
    if (!templateName.trim()) return;

    setIsCreating(true);
    try {
      const content = getTemplateContent(templateType, templateName);
      const template = createNewTemplate(templateName, content);
      onTemplateCreated?.(template.id);
      setOpen(false);
      
      // Reset form
      setTemplateName('');
      setTemplateType('');
      setDescription('');
    } catch (error) {
      console.error('Failed to create template:', error);
    } finally {
      setIsCreating(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogTrigger asChild>
        {trigger || (
          <Button>
            <Plus className="w-4 h-4 mr-2" />
            Create New Template
          </Button>
        )}
      </DialogTrigger>
      <DialogContent className="sm:max-w-[600px]">
        <DialogHeader>
          <DialogTitle className="flex items-center">
            <FileCode className="w-5 h-5 mr-2 text-purple-500" />
            Create New Template
          </DialogTitle>
          <DialogDescription>
            Create a new Jinja2 template for STM32 code generation. Choose from predefined types or create a custom template.
          </DialogDescription>
        </DialogHeader>
        
        <div className="grid gap-6 py-4">
          <div className="grid gap-2">
            <Label htmlFor="template-name">Template Name</Label>
            <Input
              id="template-name"
              placeholder="my-template"
              value={templateName}
              onChange={(e) => setTemplateName(e.target.value)}
            />
          </div>

          <div className="grid gap-2">
            <Label htmlFor="template-type">Template Type</Label>
            <Select value={templateType} onValueChange={setTemplateType}>
              <SelectTrigger>
                <SelectValue placeholder="Choose a template type" />
              </SelectTrigger>
              <SelectContent>
                {templateTypes.map((type) => (
                  <SelectItem key={type.value} value={type.value}>
                    <div className="flex flex-col">
                      <span className="font-medium">{type.label}</span>
                      <span className="text-xs text-gray-500">{type.description}</span>
                    </div>
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          <div className="grid gap-2">
            <Label htmlFor="description">Description (Optional)</Label>
            <Textarea
              id="description"
              placeholder="Describe what this template is for..."
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              rows={3}
            />
          </div>

          {templateType && (
            <div className="p-4 bg-blue-50 rounded-lg border border-blue-200">
              <div className="flex items-center mb-2">
                <Sparkles className="w-4 h-4 text-blue-500 mr-2" />
                <span className="text-sm font-medium text-blue-700">Template Preview</span>
              </div>
              <p className="text-xs text-blue-600">
                {templateTypes.find(t => t.value === templateType)?.description}
              </p>
            </div>
          )}
        </div>

        <DialogFooter>
          <Button variant="outline" onClick={() => setOpen(false)}>
            Cancel
          </Button>
          <Button 
            onClick={handleCreate} 
            disabled={!templateName.trim() || isCreating}
          >
            {isCreating ? "Creating..." : "Create Template"}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};
